ใส่ข้อมูลสำคัญใน hidden form เช่น <input type='hidden' name='dbPass' value='secret'> : ไม่ได้
https คือ stateless protocol : ใช่
ทางที่ดีที่สุดในการป้องกัน untrusted user input จากการ exploit app คือ encryption : ไม่ใช่
ใน recursive DNS query คือ client จะส่งคำขอไปยังเซิร์ฟเวอร์ DNS เพียงตัวเดียว ซึ่งอาจส่งคำขอไปยังเซิร์ฟเวอร์ DNS อื่น ๆ แทนผู้ร้องขอ จนกว่าจะสามารถกำหนดคำตอบได้ และจากนั้นจะส่งคำตอบกลับไปยังไคลเอนต์ : ใช่
มีความปลอดภัยที่จะเชื่อถือข้อมูลที่มาจาก user ใน query parameters, form field,headers,cookies,file upload : ไม่ควร
server ต้องเชื่อ http header เช่น user-agent header ที่ set จาก web browser : ไม่ใช่
หนึ่งในเหตุผลของ input validation บนฝั่งไคลเอนต์คือการหลีกเลี่ยงความจำเป็นในการติดตามข้อมูลในเซสชันของผู้ใช้ : ใช่
ทางเดียวที่ http client จะส่ง data ไป http server คือผ่าน url parameter : ใช่
ใน password base authentication การพัฒนาโปรแกรมไม่มีความต้องการที่จะเช็ค automate password guessing attack : ไม่ใช่
สำหรับ authentication , credential ของ user จะปลอดภัยเมื่อส่งผ่าน get method : ไม่ปลอดภัย

*ทำไมการรวมรายละเอียดข้อผิดพลาด ใน HTTP response เมื่อเซิร์ฟเวอร์เกิด exception จึงเป็นความคิดที่ไม่ดี

เพราะการแสดงรายละอียดข้อมูลที่ผิดพลาดอาจเปิดเผยข้อมูลภายในระบบ เช่น โครงสร้างไฟล์, คำสั่ง SQL, หรือโค้ดที่แฮ็กเกอร์สามารถใช้โจมตีได้ ควรแสดงเพียงข้อความข้อผิดพลาดทั่วไปเพื่อความปลอดภัย

*Confidentiality (การรักษาความลับ) : ป้องกันไม่ให้ข้อมูลรั่วไหล
Integrity (ความถูกต้องของข้อมูล) : ป้องกันข้อมูลถูกแก้ไขโดยไม่ได้รับอนุญาต
Availability (ความพร้อมใช้งาน) : ให้แน่ใจว่าระบบพร้อมให้บริการเสมอ
Authentication(การยืนยันตัวตน) : กระบวนการตรวจสอบและยืนยันตัวตนของผู้ใช้ เพื่อให้แน่ใจว่าผู้ใช้เป็นบุคคลที่อ้างว่าเป็น เช่น การเข้าสู่ระบบด้วยรหัสผ่านหรือการยืนยันด้วย OTP
Authorization(การกำหนดสิทธิ์) : กระบวนการกำหนดสิทธิ์และอนุญาตให้ผู้ใช้เข้าถึงหรือดำเนินการกับทรัพยากรที่กำหนด เช่น การกำหนดสิทธิ์ให้อ่านหรือแก้ไขข้อมูลในระบบ

*วิธีที่ HTTP client สามารถส่งข้อมูลไปยัง HTTP server ได้แก่

URL Parameters (GET) : ส่งข้อมูลใน URL ผ่าน query string เช่น example.com?name=John&age=30
Request Body (POST, PUT, PATCH) : ส่งข้อมูลใน body ของคำขอ เช่น ข้อมูลฟอร์ม หรือ JSON
Headers : ส่งข้อมูลใน headers ของคำขอ เช่น token หรือข้อมูลอื่น ๆ ที่เกี่ยวข้อง
Cookies : ส่งข้อมูลผ่านคุกกี้ที่เก็บไว้ในเบราว์เซอร์
File Upload : ส่งข้อมูลไฟล์ผ่านฟอร์มที่ใช้ <input type="file">

*วิธีต่าง ๆ ที่สามารถใช้ในการยืนยันตัวตน (Authentication)

Password-based Authentication : ใช้รหัสผ่านในการยืนยันตัวตน เช่น การเข้าสู่ระบบด้วยชื่อผู้ใช้และรหัสผ่าน
Two-factor Authentication (2FA) : ใช้สองขั้นตอนในการยืนยันตัวตน เช่น การใช้รหัสผ่านและรหัสที่ส่งมาทาง SMS หรือแอป Authenticator
Biometric Authentication : ใช้ลักษณะทางกายภาพของผู้ใช้ในการยืนยันตัวตน เช่น การสแกนลายนิ้วมือหรือการสแกนใบหน้า
OAuth – ระบบการยืนยันตัวตนที่ใช้ในการให้สิทธิ์การเข้าถึงโดยไม่ต้องแชร์รหัสผ่าน เช่น การเข้าสู่ระบบด้วยบัญชี Google หรือ Facebook
JWT (JSON Web Token) : ใช้โทเคนที่ลงนามและเข้ารหัสในการยืนยันตัวตน และสามารถใช้ในการยืนยันตัวตนในแอปพลิเคชันที่กระจาย
Certificate-based Authentication : ใช้ใบรับรองดิจิทัลในการยืนยันตัวตน เช่น การใช้ใบรับรอง SSL/TLS
Single Sign-On (SSO) : ระบบที่อนุญาตให้ผู้ใช้เข้าสู่ระบบครั้งเดียวและสามารถเข้าถึงแอปพลิเคชันต่าง ๆ ได้โดยไม่ต้องล็อกอินซ้ำ
PIN-based Authentication : ใช้หมายเลขส่วนตัว (PIN) ในการยืนยันตัวตน เช่น การใช้งานในโทรศัพท์มือถือ
Smart Card Authentication : ใช้บัตรอิเล็กทรอนิกส์ที่มีข้อมูลสำหรับการยืนยันตัวตน เช่น บัตรประจำตัวพนักงานที่ใช้ในการเข้าถึงระบบ

*นี่คือข้อบกพร่องในการออกแบบที่พบบ่อยในระบบการยืนยันตัวตนด้วยรหัสผ่าน (Password-based Authentication)

การโจมตีแบบ Brute-force และการเดารหัสผ่าน : ผู้โจมตีจะลองใช้การผสมผสานของรหัสผ่านหลาย ๆ แบบเพื่อเข้าถึงระบบโดยไม่ได้รับอนุญาต
การจัดเก็บและการจัดการรหัสผ่านที่ไม่ปลอดภัย : การเก็บรหัสผ่านในรูปแบบข้อความธรรมดาหรือการใช้วิธีเข้ารหัสที่อ่อนแอ
การขาดนโยบายการล็อกบัญชี : การอนุญาตให้มีการพยายามเข้าสู่ระบบได้ไม่จำกัด ทำให้ผู้โจมตีสามารถเดารหัสผ่านได้ง่ายขึ้น
ปัญหาการจัดการเซสชัน : การจัดการเซสชันที่อ่อนแอสามารถทำให้เกิดการโจมตีแบบ hijacking หรือ session fixation
ช่องโหว่ของ Cross-Site Request Forgery (CSRF) : การอนุญาตให้ผู้โจมตีสามารถทำการกระทำที่ไม่ได้รับอนุญาตในนามของผู้ใช้ที่ผ่านการยืนยันตัวตนแล้ว
Weak Passwords : ผู้ใช้มักเลือกใช้รหัสผ่านที่ง่ายต่อการเดาหรือคาดเดา เช่น "123456" หรือ "password" ซึ่งทำให้ระบบเสี่ยงต่อการถูกโจมตีแบบ brute-force หรือ dictionary attack
Password Reuse : ผู้ใช้มักใช้รหัสผ่านเดียวกันในหลายบริการ ซึ่งหากมีการรั่วไหลของข้อมูลจากบริการใดบริการหนึ่ง อาจทำให้บัญชีอื่น ๆ เสี่ยงต่อการถูกแฮ็ก
Password Storage Issues : หากรหัสผ่านเก็บไว้ในรูปแบบที่ไม่ปลอดภัย เช่น เก็บรหัสผ่านเป็นข้อความธรรมดาในฐานข้อมูล จะเสี่ยงต่อการถูกขโมยหากฐานข้อมูลถูกเจาะ
Lack of Multi-Factor Authentication (MFA) : การพึ่งพารหัสผ่านเพียงอย่างเดียวไม่ปลอดภัยเพราะอาจถูกขโมยได้ การใช้ระบบ 2FA หรือ MFA จะช่วยเพิ่มความปลอดภัย
Weak Password Policies : ไม่มีการบังคับใช้กฎในการเลือกใช้รหัสผ่านที่แข็งแกร่ง เช่น การไม่จำกัดจำนวนตัวอักษร หรือไม่มีการบังคับใช้ตัวอักษรพิเศษ, ตัวเลข, และตัวพิมพ์ใหญ่
Brute Force Vulnerability : การไม่จำกัดจำนวนการพยายามเข้าสู่ระบบอาจทำให้ระบบเสี่ยงต่อการโจมตีแบบ brute-force ที่ใช้การลองรหัสผ่านจำนวนมาก
Phishing Attacks : ผู้ใช้สามารถตกเป็นเหยื่อของการโจมตีแบบ phishing ซึ่งทำให้แฮ็กเกอร์ขโมยรหัสผ่านจากผู้ใช้ได้โดยการหลอกลวง
No Session Timeout : การไม่ตั้งค่าการหมดอายุของเซสชัน (session timeout) ทำให้ผู้ใช้ที่ไม่ออกจากระบบเสี่ยงต่อการถูกเข้าถึงข้อมูลโดยไม่ได้รับอนุญาต
No Password Expiry : รหัสผ่านที่ไม่หมดอายุหรือไม่ได้มีการเปลี่ยนแปลงเป็นระยะ ๆ อาจทำให้บัญชีเสี่ยงต่อการถูกแฮ็กจากการโจมตีแบบย้อนกลับ (replay attack)
Insecure Password Recovery : กระบวนการกู้คืนรหัสผ่านที่ไม่ปลอดภัย เช่น การใช้คำถามความปลอดภัยที่สามารถเดาได้ง่าย หรือการส่งรหัสผ่านใหม่ทางอีเมลที่ไม่เข้ารหัส


*เมื่อคุณพิมพ์ URL ลงในแถบที่อยู่ของเว็บเบราว์เซอร์แล้วส่งคำขอ อธิบายการร้องขอและการตอบกลับทั้งหมดที่เกิดขึ้นระหว่างไคลเอนต์และเซิร์ฟเวอร์จนกว่าเบราว์เซอร์จะได้รับการตอบกลับสุดท้ายจากเว็บเซิร์ฟเวอร์

http p8 draw

DNS Lookup : เบราว์เซอร์จะตรวจสอบโดเมนเนมใน URL และส่งคำขอไปยังเซิร์ฟเวอร์ DNS เพื่อแปลงโดเมนเนมเป็นที่อยู่ IP ของเซิร์ฟเวอร์เว็บ
TCP Handshake : หลังจากได้ที่อยู่ IP จาก DNS เบราว์เซอร์จะเริ่มกระบวนการเชื่อมต่อกับเซิร์ฟเวอร์โดยใช้โปรโตคอล TCP โดยเริ่มจากการส่ง SYN (synchronize) ไปยังเซิร์ฟเวอร์ จากนั้นเซิร์ฟเวอร์จะตอบกลับด้วย SYN-ACK และเบราว์เซอร์จะส่ง ACK กลับไปเพื่อให้การเชื่อมต่อเสร็จสมบูรณ์
TLS Handshake (ถ้าใช้ HTTPS) : หากการเชื่อมต่อเป็น HTTPS จะมีการแลกเปลี่ยนข้อมูลการเข้ารหัสระหว่างเบราว์เซอร์และเซิร์ฟเวอร์ เช่น การแลกเปลี่ยนใบรับรอง SSL/TLS
HTTP Request : เบราว์เซอร์จะส่งคำขอ HTTP ไปยังเซิร์ฟเวอร์เว็บ เช่น คำขอ GET, POST หรือวิธีอื่น ๆ ขึ้นอยู่กับ URL ที่พิมพ์ คำขอจะรวมถึง headers (เช่น User-Agent, Accept-Encoding) และ cookies (ถ้ามี)
Web Server Processing : เซิร์ฟเวอร์เว็บจะประมวลผลคำขอและตอบกลับด้วย HTTP Response ซึ่งรวมถึง status code (เช่น 200 OK, 404 Not Found), headers และ body (ข้อมูลที่ร้องขอ เช่น HTML, CSS, JavaScript)
Browser Rendering : เบราว์เซอร์รับข้อมูลจากเซิร์ฟเวอร์และเริ่มการเรนเดอร์หน้าเว็บ โดยการตีความ HTML, CSS และการประมวลผล JavaScript ตามลำดับ
Additional Requests : หากหน้าเว็บมีทรัพยากรเพิ่มเติม (เช่น รูปภาพ, ไฟล์ CSS หรือ JavaScript) เบราว์เซอร์จะทำการส่งคำขอเพิ่มเติมไปยังเซิร์ฟเวอร์หรือเซิร์ฟเวอร์ที่เกี่ยวข้องเพื่อนำข้อมูลเหล่านั้นมาทำการแสดงผล
Final Rendering : หลังจากที่เบราว์เซอร์ได้รับข้อมูลทั้งหมดและประมวลผลเสร็จสิ้น หน้าเว็บจะถูกแสดงผลให้ผู้ใช้เห็นในที่สุด



